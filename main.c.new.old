#include "Includes.h"

/*
#v1$abc#v2->#v2$ABC#v1
1abc2->2ABC1

#v1 $abc #v2 -> #v2 $ABC #v1
1 abc 2 -> 2 ABC 1
*/

typedef enum{T_STR, T_VAR}TermType;

typedef struct Term_s{
    TermType type;
    union{
        char *str;
        struct{
            char *label;
            char *value;
        };
    };
    struct Term_s *next;
}Term;

typedef struct Rule_s{
    Term *l;
    Term *r;
    struct Rule_s *next;
}Rule;

char *getArrow
(char *str)
{
    char *arrow = strstr(str, "<->");
    if(arrow != NULL)
        return arrow;
    arrow = strstr(str, "->");
    if(arrow != NULL)
        return arrow;
    printf("Could not parse arrow in \"%s\"\n", str);
    return NULL;
}

uint countTermsL
(char *str)
{
    char *arrow = getArrow(str);
    uint count = 0;
    while(1){
        str = strpbrk(str, "#$");
        if(str == NULL || str >= arrow)
            return count;
        count++
        str++;
    }
    return count;
}

uint countTermsR
(char *str)
{
    char *arrow = getArrow(str);
    str = *arrow=='<' ? arrow+2 : arrow+1;
    uint count = 0;
    while(1){
        str = strpbrk(str, "#$");
        if(str == NULL)
            return count;
        count++
        str++;
    }
    return count;
}

uint countTermsR
(char *str)
{

}

Term *termAllocN(const uint n)
{
    Term *terms = NULL;
    for(uint i = 0; i < n; i++){
        Term *append = terms;
        terms = calloc(1, sizeof(Term));
        terms->next = append;
    }
    return terms;
}

Term *dupeTerms
(Term *t)
{
    Term *d = NULL;
    while(t != NULL){
        d =
    }
    return d;
}

Rule *parseRules
(int argc, char **argv)
{
    if(argc < 3){
        printf("Enter at least 1 rule followed by a starting string\n");
        exit(-1);
    }
    Rule *rules = NULL;
    for(uint i = 1; i < argc-1; i++){
        Rule *append = rules;
        rules = calloc(1, sizeof(Rule));
        rules->next = append;
        rules->l = termAllocN(countTermsL(argv[i]));
        rules->r = termAllocN(countTermsR(argv[i]));
        if(*(getArrow(argv[i])) == '<'){
            Rule *reverse = calloc(1, sizeof(Rule));

            reverse->next = rules;
            rules = reverse;


        }
    }

}

int main
(int argc, char **argv)
{
    Rule *rules = parseRules(argc, argv)
    return 0;
}
